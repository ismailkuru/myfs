\section{Btrfs}

Btrfs - файловая система для ядра Linux, которая основана на использовании COW
модификации B+ деревьев~\cite{BCOW}. B+ деревья в Btrfs используются для всего:
\begin{itemize}
  \item для хранения информации о занятых/свободных участках диска используется
        дерево экстентов;
  \item для хранения информации о файлах/каталогах используется дерево файловой
        системы, которое хранит индексные узлы (inode) и записи каталогов
        (dentry);
  \item корни всех деревьев хранятся в еще одном дереве, которое называют
        корневым.
\end{itemize}

Как и ZFS, Btrfs обладает очень богатой функциональностью, обсуждение которой
выходит за рамки данной работы. Вместо этого в данной работе поверхностно
обсуждается основная индексная структура лежащая в основе Btrfs.

\subsection{B деревья и их вариации}

B деревья - это сильноветвистые идеально сбалансированные деревья поиска.
Классические алгоритмы вставки и удаления ключей из B дерева описанные в
~\cite{BTree} состоят из двух проходов по дереву:
\begin{itemize}
  \item проход от корня вниз по дереву для поиска позиции для вставки или ключа
        для удаления;
  \item балансировка начиная от измененного узла вверх в сторону корня.
\end{itemize}

Для балансировки используются несколько операций:
\begin{itemize}
  \item если после вставки в узел количество ключей в узле стало слишком
        большим, то узел расщепляется на два, а родительский узел добавляется
        ссылка на новый узел;
  \item если после удаления из узла количество ключей в узле стало слишком
        маленьким, то можно либо перераспределить ключи соседних узлов либо
        объединить узел с одним из соседей, при этом опять же придется изменять
        родительский узел.
\end{itemize}

B+ деревья поиска - это вариации B деревьев, в которой значения всегда хранятся
в листьях. Внутренние узлы хранят только ключи необходимые для поиска нужного
листа.

Для B+ деревьев на протяжении времени было предложено несколько схем
синхронизации, который позволяют выполнять конкурентные запросы к индексу
сравнительно эффективно. Одним из лучших таких подходов считается модификация,
которая называется B-link деревья предложенная в~\cite{BLink}. Однако в данной
модификации узлы одного уровня связаны в список и эта связь является
существенной для работы алгоритма. К несчастью ссылка на соседний узел делает
этот подход непригодным для COW.

\subsection{COW B+ деревья}

COW B+ деревья предложенные в~\cite{BCOW} отличаются от большинства классических
подходов в двух аспектах:
\begin{itemize}
   \item отсутствует ссылка на соседние узлы, только ссылки из родителя на
         ребенка;
   \item алгоритмы вставки и удаления выполняют проактивную балансировку по
         мере прохода по дереву от корня к листу.
\end{itemize}

Суть проактивного подхода к балансировке заключается в следующем. Если при
выполнении операции в ставки ключа в дерево на пути от корня у нужному листу
был найден полный узел дерева, т. е. узел вставка в который приведет к его
расщеплению, то это расщепление выполняется сразу же не дожидаясь, пока вставка
в этот узел действительно произойдет. Аналогичным образом происходит и при
операции удаления, только в этом случае алгоритм объединяет узлы с малым числом
ключей с соседними узлами или перераспределяет ключи.

По мере прохода по дереву от корня к листу для синхронизации используется подход
называемый lock coupling или crabbing. Суть подхода заключается в том, что
блокировка родительского узла освобождается только после того, как была
захвачена блокировка ребенка. При условии что проход по дереву всегда идет в
одном направлении возможность взаимной блокировки будет исключена. Однако если
работа с деревом всегда начинается с корневого узла, все потоки исполнения
должны захватывать блокировку корня, что плохо способствует параллельной работе
с таким деревом. И если при использовании read/write блокировки читатели могут
работать параллельно, то потокам писателям придется захватывать блокировки в
эксклюзивное пользование.
