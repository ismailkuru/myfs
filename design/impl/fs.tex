\section{Реализация файловой системы}

Имея на руках готовую реализацию словаря в виде LSM-дерева можно использовать
его в качестве индексной структуры для файловой системы. Более того так как
LSM-деревья не перезаписывают словари на диске, а вместо этого создают новые, то
по крайней мере индексы файловой системы автоматически будут COW.

В myfs в силу ее простоты и небогатой функциональности достаточно всего двух
LSM-деревьев (см. структуру myfs в файле inc/myfs.h):
\begin{itemize}
  \item inode\_map - хранит так называемые индексные узлы;
  \item dentry\_map - хранит дерево каталогов.
\end{itemize}
Структура элементов и назначение каждого из этих LSM-деревьев в деталях
обсуждается далее в этом разделе.


\subsection{Библиотека FUSE}

Filesystem in Userspace (далее FUSE) - это библиотека и драйвер ядра ОС, который
позволяет реализовать драйвер файловой системы совершенно полностью в
пространстве пользователя. Использование FUSE упрощает разработку файловой
системы в ряде аспектов:
\begin{itemize}
  \item для пространства пользователя доступно множество средств диагностики и
        отладки приложений;
  \item разрабатывать файловую систему можно на любом удобном языке при условии,
        что есть возможность подключения библиотеки в языку.
\end{itemize}

При этом разработанная файловая система может использоваться наравне с файловыми
системами включенными в ядро ОС. Благодаря этому можно без изменений
использовать бенчмарки и тесты существующие для файловых систем.

Однако использование FUSE также может отразиться на производительности в связи
с тем, что каждый запрос к файловой системе сначала поступает в ядро, потом из
ядра через FUSE передается в пространство пользователя драйверу файловой
системы. Ответ на каждый запрос аналогичным образом передается назад
пользователю. Кроме того, если файловая система пользуется интерфейсом
ввода/вывода предоставляемым ядром ОС, то это еще дополнительные расходы на
системные вызовы, которых не было бы у драйвера ядра.


\subsubsection{Интерфейс файловой системы}

Существует два вида интерфейсов, которые должен реализовать драйвер файловой
системы чтобы использовать FUSE. Эти интерфейсы условно называются
низкоуровневым и высокоуровневым. Высокоуровневый интерфейс в основном состоит
из набора функций похожих на стандартные для Unix операций работы с файлами и
каталогами:
\begin{lstlisting}
struct fuse_operations {
    ...
    int (*mkdir) (const char *, mode_t);
    int (*unlink) (const char *);
    int (*rmdir) (const char *);
    int (*symlink) (const char *, const char *);
    int (*rename) (const char *, const char *, unsigned int);
    int (*link) (const char *, const char *);
    ...
    int (*open) (const char *, struct fuse_file_info *);
    int (*read) (const char *, char *, size_t, off_t,
                 struct fuse_file_info *);
    int (*write) (const char *, const char *, size_t, off_t,
                  struct fuse_file_info *);
    ...
    int (*opendir) (const char *, struct fuse_file_info *);
    int (*readdir) (const char *, void *, fuse_fill_dir_t, off_t,
                    struct fuse_file_info *, enum fuse_readdir_flags);
    ...
};
\end{lstlisting}

За исключением некоторого отличия в количестве и именах операций низкоуровневый
интерфейс отличается от высокуровневого типом идентификатора файла/каталога. В
высокоуровневом интерфейсе используется путь, в то время к в низкоуровневом
интерфейсе для этого используется номер индексного узла (далее просто inode):
\begin{lstlisting}
struct fuse_lowlevel_ops {
    ...
    void (*lookup) (fuse_req_t req, fuse_ino_t parent, const char *name);
    ...
    void (*mknod) (fuse_req_t req, fuse_ino_t parent, const char *name,
                   mode_t mode, dev_t rdev);
    void (*mkdir) (fuse_req_t req, fuse_ino_t parent, const char *name,
                   mode_t mode);
    void (*unlink) (fuse_req_t req, fuse_ino_t parent, const char *name);
    void (*rmdir) (fuse_req_t req, fuse_ino_t parent, const char *name);
    void (*symlink) (fuse_req_t req, const char *link, fuse_ino_t parent,
                     const char *name);
    void (*rename) (fuse_req_t req, fuse_ino_t parent, const char *name,
                    fuse_ino_t newparent, const char *newname,
                    unsigned int flags);
    void (*link) (fuse_req_t req, fuse_ino_t ino, fuse_ino_t newparent,
                  const char *newname);
    void (*read) (fuse_req_t req, fuse_ino_t ino, size_t size, off_t off,
                  struct fuse_file_info *fi);
    void (*write) (fuse_req_t req, fuse_ino_t ino, const char *buf,
                   size_t size, off_t off, struct fuse_file_info *fi);
    ...
    void (*readdir) (fuse_req_t req, fuse_ino_t ino, size_t size, off_t off,
                     struct fuse_file_info *fi);
    ...
};
\end{lstlisting}

Так как работать с номерами индексных узлов несколько проще чем с полными
именами, то в реализации принято решение использовать низкоуровневый интерфейс.


\subsection{Хранение дерева каталогов}

Для хранения дерева каталогов в myfs используется LSM-дерево dentry\_map. В
качестве ключа в дереве выступает структура \_\_myfs\_dentry\_key (см. файл
inc/dentry.h):
\begin{lstlisting}
struct __myfs_dentry_key {
    le64_t parent;
    le32_t hash;
    le32_t size;
    char name[1];
} __attribute__((packed));
\end{lstlisting}

Ключ хранит номер inode каталога, которому принадлежит эта запись - parent. А
также хеш имени, длина имени (без учета завершающего нулевого символа) и само
имя записи в каталоге. Все эти поля участвую в сравнении.

В качестве значения используется структура \_\_myfs\_dentry\_value:
\begin{lstlisting}
    le64_t inode;
    le32_t type;
\end{lstlisting}
В значение входят аттрибуты которые не участвуют в сравнении: номер inode
файла/каталога, на который ссылается запись, и тип (файл или каталог).

Таким образом информация о дереве каталогов файловой системы внутри dentry\_map
кодируется в виде ссылки на родителя.


\subsubsection{Поиск файла/каталога в каталоге по имени}

Чтобы уметь обходить дерево каталогов ОС от файловой системе требуется
реализация операции поиска по имени внутри заданного каталога. В структуре
fuse\_lowlevel\_ops за эту операцию отвечает поле lookup.

В случае dentry\_map эта операция реализуется как обычный точечный поиск. В
качестве ключа используется номер inode каталога и имя (хеш, длина имени и само
имя).


\subsubsection{Итерация по каталогу}

Для реализации таких команд как ls, ОС предоставляет интерфейс, который
позволяет перечислять содержимое каталога. В структуре fuse\_lowlevel\_ops
за итерацию по каталогу отвечает поле readdir:
\begin{lstlisting}
    void (*readdir) (fuse_req_t req, fuse_ino_t ino, size_t size, off_t off,
                     struct fuse_file_info *fi);
\end{lstlisting}

В качестве параметров операция принимает номер inode каталога, содержимое
которого необходимо перечислить, а также смещение (off). Однако смещение не смотря на
название не обязано обозначать смещение внутри каталога. Это может быть любое
целое число, которое каким-то образом сообщит драйверу файловой системы с какого
места в каталоге нужно начать перечисление. Изначально смещение должно быть
равно 0. Все значения отличные от 0, это значения возвращенные файловой
системой, соответственно, она должна знать как именно их использовать.

Все записи в dentry\_map принадлежащие одному каталогу упорядочены по хешу.
Таким образом можно использовать хеш в качестве смещения внутри каталога. Таким
образом myfs и использует хеш имени в текущей реализации. Однако стоит отметить,
что в редких случаях коллизий хешей и неудачном стечении обстоятельств
последовательное применение операции readdir чтобы прочитать содержимое каталога
может привести к тому, что некоторые записи в каталоге "потеряются". Такой же
проблемой обладает, например, файловая система ext4.

Существуют способы исправить эту проблему, однако на данный момент они не
реализованы и поэтому будут рассмотрены в разделе~\ref{sec:todo}.


\subsection{Словарь inode-ов}

Индексный узел или inode - это некоторая структура файловой системы, котрая
хранит информацию о файле или каталоге. Информация, которую хранит inode, может
включать в себя:
\begin{itemize}
  \item тип (файл, каталог или какая-то другая сущность файловой системы);
  \item владелец файла (пользователь, группа пользователя);
  \item права доступа к файлу (кто может его читать/писать/исполнять);
  \item различные временные метки (дата создания, дата модификации, дата
        доступа);
  \item различные атрибуты связанные с размером (каков логический размер файла
        каталога, сколько места занято на диске);
  \item информация о местах диска, где размещено содержимое файла/каталога.
\end{itemize}

Чтобы получить примерное представление об информации, которую хранит inode можно
обратиться к структуре stat определенной в стандарте POSIX\footnote{Данная
версия взята не из стандарта POSIX, а из описания man 2 stat согласующегося со
спецификацией POSIX.}:
\begin{lstlisting}
struct stat {
    dev_t     st_dev;         /* ID of device containing file */
    ino_t     st_ino;         /* inode number */
    mode_t    st_mode;        /* protection */
    nlink_t   st_nlink;       /* number of hard links */
    uid_t     st_uid;         /* user ID of owner */
    gid_t     st_gid;         /* group ID of owner */
    dev_t     st_rdev;        /* device ID (if special file) */
    off_t     st_size;        /* total size, in bytes */
    blksize_t st_blksize;     /* blocksize for filesystem I/O */
    blkcnt_t  st_blocks;      /* number of 512B blocks allocated */

    /* Since Linux 2.6, the kernel supports nanosecond
       precision for the following timestamp fields.
       For the details before Linux 2.6, see NOTES. */
     struct timespec st_atim;  /* time of last access */
     struct timespec st_mtim;  /* time of last modification */
     struct timespec st_ctim;  /* time of last status change */

     #define st_atime st_atim.tv_sec      /* Backward compatibility */
     #define st_mtime st_mtim.tv_sec
     #define st_ctime st_ctim.tv_sec
};
\end{lstlisting}


В myfs для хранения inode-ов используется отдельное LSM-дерево inode\_map.
Ключом в этом дереве является структура \_\_myfs\_inode\_key (см. файл
inc/inode.h):
\begin{lstlisting}
struct __myfs_inode_key {
    le64_t inode;
} __attribute__((packed));
\end{lstlisting}

А в качестве значения выступает структура \_\_myfs\_inode\_value:
\begin{lstlisting}
struct __myfs_bmap_entry {
    le64_t disk_offs;
    le64_t file_offs;
} __attribute__((packed));

struct __myfs_bmap {
    le32_t size;
    struct __myfs_bmap_entry entry[1];
} __attribute__((packed));

struct __myfs_inode_value {
    le64_t size;
    le64_t mtime;
    le64_t ctime;
    le32_t links;
    le32_t type;
    le32_t uid;
    le32_t gid;
    le32_t perm;
    struct __myfs_bmap bmap;
} __attribute__((packed));
\end{lstlisting}

Все элементы в inode\_map упорядочены по номеру inode. Значения в LSM-дереве
хранят обычные для файловой системы в Unix-подобной ОС атрибуты файла/каталога.
Фактически, единственная операция, которая требуется от inode\_map - это поиск
значения по ключу, т. е. inode\_map работает как расширяемый разреженный массив.

Информация о расположении файла на диске хранится в виде просто массива записей.
Такой простой формат представления позволяет работать достаточно просто с
небольшими файлами, однако он мало пригоден для полноценной файловой системы.
Рассмотрение возможных альтернатив отложено до раздела~\ref{sec:todo}.


\subsection{Правила синхронизации}

Многие операции модифицирующие файловую систему требуют обновления сразу и
inode\_map и dentry\_map, либо нескольких обновлений одного из них. Например,
создание файла требует добавление inode в inode\_map, обновления inode
родительского каталога в inode\_map и добавление записи в dentry\_map. Чтобы
выполнить эти операции атомарно синхронизации внутри LSM-дерева не достаточно.

Чтобы синхронизировать выполнение операций над файловой системой для каждого inode
дополнительно создается read/write блокировка. Для модификации или чтения inode
должна быть захвачена соответствующая блокировка. Далее подробнее
рассматриваются некоторые операции над файловой системой и порядок блокировок
при выполнении этих операций.

\paragraph{Операция lookup.} Операция поиска файла/каталога внутри некоторого
родительского каталога по имени. На время выполнения ээтой операции read/write
блокировка соответствующая inode родительского каталога должна быть захвачена на
чтение.

\paragraph{Операция getattr.} Операция получения информации о файле/каталоге по
номеру его inode. На время выполнения операции inode должен быть заблокирован на
чтение.

\paragraph{Операция setattr.} Операция изменения информации о файле/каталоге по
номеру его inode. На время выполнения операции inode должен быть заблокирован на
запись.

\paragraph{Операции mknod и mkdir.} Операции создания файла/каталога. В качестве
аргументов операции принимают номер inode родительского каталога и имя
файла/каталога, который необходимо создать. На время выполнения операции inode
родительского каталога должен быть заблокирован на запись.

\paragraph{Операции unlink и rmdir.} Операция удаления файла/каталога из
родительского каталога. На время выполнения операции inode родительского
каталога должен быть заблокирован на запись как и inode удаляемого
файла/каталога.

\paragraph{Операция link.} Операция создания жесткой ссылки на файл в некотором
кталоге. На время операции inode каталога и inode файла оба должны быть
заблокированы на запись.

\paragraph{Операция readdir.} Операция итерации по содержимому каталога. На
время выполнения операции inode каталога должен быть заблокирован на чтение.

\paragraph{Операция rename.} Операция изменения имени файла/каталога. В качестве
параметров операция принимает inode родительского каталога и имя файла/каталога
в нем, а также inode нового родительского каталога и имя файла/каталога в нем.
Оба родительских inode-а должны быть заблокированы на запись. Чтобы избежать
взаимной блокировки inode-ы родительских каталогов блокируются в порядке номеров
их inode-ов.

Более того, согласно стандартной семнатике операции rename, если в новом
родительском каталоге уже существует файл с заданным именем он должен быть
атомарно удален. В этом случае дополнительно должна быть захвачена на запись
блокировка удаляемого inode.


\subsection{Создание контрольной точки}
\label{sec:commit}

При работе файловые системы обычно накапливают изменения в памяти, после чего
изменения группой выписываются на диск так, чтобы состояние файловой системы на
диске было консистентным. Этот процесс называется созданием контрольной точки
(checkpoint). Файловые системы могут самостоятельно выбирать время для создания
контрольной точки, а кроме этого создание контрольной точки может инициироваться
пользователем.

Для создания контрольной точки необходимо зафиксировать консистентное состояние
inode\_map и dentry\_map на диске и сохранить указатели на корни LSM-деревьев в
специальное место на диске. Место на диске, в которое записывается информация о
контрольной точке определяется при форматировании файловой системы и никогда не
меняется. Таким образом при монтировании файловой системы необходимо прочитать
информацию о последней контрольной точке из зафиксированного места на диске.


\subsubsection{Структура контрольной точки}

Структура описывающая контрольную точку называется \_\_myfs\_check (см. файл
inc/myfs.h):
\begin{lstlisting}
struct __myfs_check {
    le64_t csum;
    le64_t gen;
    le64_t ino;
    struct __myfs_lsm_sb inode_sb;
    struct __myfs_lsm_sb dentry_sb;
} __attribute__((packed));
\end{lstlisting}

Вместе с корнями LSM-деревьев в контрольной точке также сохраняется контрольная
сумма для проверки целостности контрольной точки и следующий свободный номер
inode.


\subsubsection{Фиксация состояния LSM-деревьев}

Состояние LSM-дерева состоит из части созраненной на диске и части хранящейся в
памяти. Для того, чтобы создать контрольную точку нужно перенести часть
состояния LSM-дерева из памяти на диск. Для этого реализация LSM-деревьев в myfs
поддерживает операцию flush.

Однако ситуация усложняется тем, что в myfs есть два LSM-дерева существующих
независимо друг от друга и некоторые операции над файловой системой модифицируют
оба LSM-дерева, а сохраненное на диске состояние dentry\_map и inode\_map должно
быть консистентным.

Например, над файловой системой выполняется операция создания файла. Эта
операция создает inode для нового файла и добавляет его в inode\_map. Кроме того
эта операция создает запись в каталоге и добавляет эту информацию в dentry\_map.
Если при создании файла конкурентно создавалась контрольная точка, то, если не
принять мер, может получится так, что dentry\_map, сохраненный на диске, будет
содержать ссылку на несуществующий inode или наоборот в inode\_map будет inode,
на который никто не ссылается.

Чтобы избежать такой ситуации dentry\_map и inode\_map должны выписываться на
диск согласованно. Для этого используется read/write блокировка trans\_lock. Все
операции модифицирующие LSM-деревья захватывают trans\_lock на чтение, а при
создании контрольной точки эта блокировка захватывается на запись тем самым
эффективно останавливая модификацию LSM-деревьев.

Естественно не хотелось бы останавливать запись на продолжительное время. Для
того, чтобы по возможности избегать этого операция flush обсуждавшаяся ранее
разбита на два этапа: перенос $C_0$ в $C_1$ и объединение $C_1$ с $C_2$. Первый
этап выполняется быстро, а вот второй требует чтения и записи на диск и может
занять сравнительно продолжительное время. Поэтому после завершения первого
этапа flush деревьев inode\_map и dentry\_map блокировка trans\_lock
освобождается. При этом уровни $C_1$-$C_5$ хранят консистентное состояние
LSM-деревьев в некоторый момент времени. Именно это состояние и будет
зафиксировано на диске втором этапе операции flush.


\subsubsection{Запись контрольной точки на диск}

В myfs за создание контрольных точек отвечает отдельный поток исполнения -
flusher. Flusher пытается создавать контрольную точку не реже чем раз в минуту
либо по мере наполнения LSM-деревьев inode\_map и dentry\_map данными. Если хотя
бы одно из деревьев требует сохранения на диск, flusher пытается создать
контрольную точку.

В текущей реализации myfs информация о контрольной точке помещается в 512 байт,
что означает, что на современном оборудовании контрольная точка может быть
атомарно записана на диск. Однако myfs не полагается на это, вместо этого myfs
резервирует под контрольную точку два участка на диске. При создании контрольной
точки сначала записывается первый из них, после чего происходит сброс всех
буферов на диск, затем та же самая информация записывается во второй
зарезервированный участок. При таком подходе, даже если запись контрольной
точки будет прервана, myfs все еще сможет использовать резервную копию старой
контрольной точки.
